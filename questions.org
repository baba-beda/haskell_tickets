* Вопросы по темам 
** [5/5]Question 1: Intro
*** DONE Перечислите основные парадигмы ФП и Haskell, отличительные особенности
1. FP: 
   1. Иммутабельность
   2. Чистота
   3. Статическая типизация и вывод типов
   4. Функции высшего порядка
2. Haskell:
   1. Ленивые вычисления
   2. Pattern matching
   3. Type classes
*** DONE Укажите преимущества чистоты
1. Есть referential transparency \Rightarrow есть бОльшие возможности для оптимизации
2. Проще делить программу на независимые модули и отлаживать их по отдельности (\approx один модуль - одна функция) 
3. Чистые фукнции проще объединять в композиции, так как между ними нет неявных связей в виде изменяемого состояния
4. Чисто функциональные программы проще сделать параллельными
*** DONE Укажите преимущества ленивых вычислений
1. Можно присваивать значения в любом порядке, так как при ленивых вычислениях вычисление значения произойдет только при его использовании
2. Можно использовать бесконечные структуры данных
3. Ленивый язык более выразительный, чем строгий
4. Иногда можно улучшить эффективность использования памяти при ленивых вычислениях.
*** DONE Укажите преимущества иммутабельности
1. Нет проблемы нелокальности: изменение по одной ссылке не приведет к изменениям по остальным ссылкам, так как "изменяющая" функция вернет новый объект
2. Нет необходимости в копировании объектов
3. Инварианты достаточно проверять только при создании объекта
4. Нет зависимости от истории \Rightarrow нет зависимости от порядка вызова методов
5. Безопасное хранение объекта в коллекции
6. Не требуется синхронизация, так как все потоки только читают данные
*** DONE Укажите преимущества статической типизации
1. Раннее обнаружение ошибок :: Ошибки находятся на этапе компиляции, а не выполнения. Часто программа на SML или Haskell работает правильно, как только ее наконец удается скомпилировать
2. Высокая поддерживаемость больших проектов :: Изменения могут быть верифицированы компилятором, и типы являются частью документации программы, облегчая ее понимание
3. Автоматизированная обработка программ :: Например, автоматический рефакторинг, как в средах IDEA или Eclipse
4. Оптимизация кода :: Код, написанный на статически типизированном языке, проще оптимизировать, так что в среднем статически типизированный язык эффективнее динамически типизированных
** [13/16]Question 2: Basic Syntax
*** TODO Имеется класс типов: ~class C a where maxInt :: Int~. Реализуйте данный класс типов для какого-нибудь типа данных.
*** TODO Имеется класс типов: ~class C a where intGetter :: a -> Int~. Реализуйте данный класс типов для какого-нибудь типа данных.
*** TODO Как обновить ~f~ в ~data A = A { f :: Int -> Int }; c = A { b = (+1) }~?
*** DONE Что дает слово "*deriving*"? Что это в языке Haskell? 
~deriving~ позволяет неявно определять функции стандартных ~typeclass~'ов. Детали такой неявной реализации иногда зависят от компилятора. 
*** DONE Напишите реализацию ~foldr~ и ~foldl~. И нарисуйте картинку вычисления
~foldr~:
[[./images/foldr.png]]
#+BEGIN_SRC haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z []     = z
foldr f z (x:xs) = x `f` (foldr f z xs)
#+END_SRC
~foldl~:
[[./images/foldl.png]]
#+BEGIN_SRC haskell
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl _ z []     = z
foldl f z (x:xs) = foldl (f z x) xs
#+END_SRC
*** DONE Синтаксическим сахаром для какого кода является объявление следующего типа данных: ~data MyData = A { f :: Int, g :: Int -> Double }~
#+BEGIN_SRC haskell
data MyData = A Int (Int -> Double) 
#+END_SRC
*** DONE Напишите тип выражения ~flip id~.
#+BEGIN_SRC haskell
id :: a -> a
flip :: (a -> b -> c) -> b -> a -> c
-- a ≡ b -> c
flip id :: b -> (b -> c) -> c
#+END_SRC
*** DONE Напишите тип выражения ~((+) . )~
#+BEGIN_SRC haskell
(+) :: Num n => n -> n -> n
(.) :: (b -> c) -> (a -> b) -> a -> c
-- b ≡ n; c ≡ n -> n
((+) . ) :: (a -> n) -> a -> n -> n
#+END_SRC
*** DONE Напишите тип выражения ~(.) . (.)~
#+BEGIN_SRC haskell
-- left arg
(.) :: (b1 -> c1) -> (a1 -> b1) -> a1 -> c1
-- right arg 
(.) :: (b2 -> c2) -> (a2 -> b2) -> a2 -> c2
-- b ≡ b1 -> c1 ≡ ((a2 -> b2) -> (a2 -> c2)); c ≡ (a1 -> b1) -> (a1 -> c1)
-- a ≡ b2 -> c2 
((.) . (.)) :: (b2 -> c2) -> (a1 -> a2 -> b2) -> (a1 -> a2 -> c2)
#+END_SRC
*** DONE Имеется тип данных ~data A a = B { f :: Double }~. Укажите тип ~f~.    
#+BEGIN_SRC haskell
f :: A a -> Double
#+END_SRC
*** DONE В чем отличие ~data~ от ~newtype~?
~newtype~ гарантирует, что данные будут иметь такой же вид в рантайме, как и завернутый тип. То есть Конструктор для ~newtype~ гарантированно стирается во время компиляции.
~data~ объявляет абсолютно новую структуру данных в рантайме.
*** DONE Что такое "*Currying* (каррирование)" и *функции высшего порядка*?
*Каррирование* Вычисление функции, принимающей несколько аргументов, через несколько функций, принимающих один аргумент. 
Например, для функции 2-х аргументов h:(A \times B) \to C оператор каррирования \Lambda выполняет преобразование \Lambda(h):A \to (B \to C). То есть \Lambda: ((A \times B) \to C) \to (A \to (B \to C)).
#+BEGIN_SRC haskell
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
#+END_SRC
*Функции высшего порядка* Функции, принимающие в качестве аргументов другие функции или возвращающие другие функции в качестве результата. 
#+BEGIN_SRC haskell
map :: (a -> b) -> [a] -> [b]
filter :: (a -> Bool) -> [a] -> [a]
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
#+END_SRC
*** DONE Напишите, что такое DatatypeContexts? Приведите пример (не из презентации)
Ограничения на параметры в объявлениях ~data~ и ~newtype~. Объявленные таким образом типы требуют выполнения ограничений при создании (/construction/) и деконструкции (/deconstruction/, \approx разбиение конструктора при паттерн-матчинге), даже если эти ограничения неиспользуются. (deprecated in Haskell 7.2)
#+BEGIN_SRC haskell
data Eq a => Foo a = Constr a

-- не можем написать функцию:
isEq :: Foo a -> Foo a -> Bool
-- должны написать:
isEq :: Eq a => Foo a -> Foo a -> Bool
isRa (Constr x) (Constr y) = x == y

-- не сработает:
getVal :: Foo a -> a
-- сработает:
getVal :: Eq a => Foo a -> a
getVal (Constr x) = x
#+END_SRC
*** DONE Напишите тип следующей функции в наиболее общем виде: ~f a = map (* a) . map (uncurry (+)) . map (\x -> (x, x))~
#+BEGIN_SRC haskell 
f :: Num a => a -> [a] -> [a]
#+END_SRC
*** DONE Напишите функцию с типом, которая принимает список пар чисел и оставляет только такие, что сумма чисел в паре четная.
#+BEGIN_SRC haskell
evenPairs :: (Integral a) :: [(a, a)] -> [(a, a)]
evenPairs = filter (even . uncurry (+))
#+END_SRC 
*** DONE Задан тип данных ~data Role a = A { name :: String, role :: a } | B { name :: String, roles :: [a] }~. Напишите конструкцию, синтаксическим сахаром для которой является данных Record Syntax.
#+BEGIN_SRC haskell
data Role a = A String a | B String [a]
#+END_SRC
** [8/10]Question 3: Kinds
*** DONE Приведите пример типа с kind'ом ~Constraint -> *~
#+BEGIN_SRC haskell
type P a = a => Int
#+END_SRC
*** TODO Приведите пример типа с kind'ом ~(* -> Constraint) -> Constraint~
*** DONE Приведите пример типа с kind'ом ~(* -> *) -> Constraint~
~Monad, Functor, Applicative~
*** DONE Приведите пример типа с kind'ом ~(* -> Constraint) -> *~
#+BEGIN_SRC haskell 
type P a = a Int => Int
#+END_SRC
*** DONE Приведите пример типа с kind'ом ~* -> Constraint~
~Num, Ord, Eq, Show~
*** DONE Укажите kind для ~Monad~
~(* -> *) -> Constraint~
*** TODO Укажите kind следующего типа данных: ~data A f g = B (f g) (g f)~
*** DONE Укажите kind следующего типа данных: ~data A f g = B (f g Int)~
~A :: (* -> * -> *) -> * -> *~
*** DONE Укажите kind типа ~type C p = p Int => Int~
~C :: (* -> Constraint) -> *~
*** DONE Укажите kind типа ~type C p = (p Int, p Double)~
~C :: (* -> *) -> *~
<<<<<<< HEAD
** [14/14]Question 4: Type hierarchy
*** DONE Чему равно значение ~length (Left "hello")~ и почему?
0
#+BEGIN_SRC haskell
length = foldr (\_ n -> 1 + n) 0
#+END_SRC 
*** DONE Чему равно значение ~length (Just [1..10])~ и почему?
1
*** DONE Напишите type class ~Traversable~
#+BEGIN_SRC haskell
class (Functor t, Foldable t) => Traversable t where
  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
  traverse f = sequenceA . fmap f
  sequenceA :: Applicative f => t (f a) -> f (t a)
  sequenceA = traverse id
  mapM :: Monad m => (a -> m b) -> t a -> m (t b)
  mapM = traverse
  sequence :: Monad m => t (m a) -> m (t a)
  sequence = sequenceA
#+END_SRC
*** DONE Напишите реализацию ~Traversable~ для списка
#+BEGIN_SRC haskell
instance Traversable [] where
    traverse f = foldr consF (pure [])
    where 
       consF x ys = (:) <$> f x <*> ys
#+END_SRC
*** DONE Напишите реализацию ~Traversable~ для ~Maybe~ 
#+BEGIN_SRC haskell
instance Traversable Maybe where
    traverse _ Nothing  = pure Nothing
    traverse f (Just x) = Just <$> f x
#+END_SRC
*** DONE Напишите реализацию ~Traversable~ для ~Either~
#+BEGIN_SRC haskell
  instance Traversable (Either a) where
      traverse _ (Left x) = pure (Left x)
      traverse f (Right y) = Right <$> f y
#+END_SRC
*** DONE Напишите реализацию ~Foldable~ для списка 
#+BEGIN_SRC haskell
instance Foldable [] where
    foldMap _ []     = mempty
    foldMap f (x:xs) = f x <> foldMap f xs
#+END_SRC
*** DONE Напишите реализацию ~Foldable~ для ~Maybe~
#+BEGIN_SRC haskell
instance Foldable Maybe where 
    foldr f zero Nothing = zero  
    foldr f zero (Just x) = f x zero 
#+END_SRC
*** DONE Напишите реализацию ~Foldable~ для ~Either~
#+BEGIN_SRC haskell
instance Foldable Either where 
    foldr f zero Left = zero  
    foldr f zero (Right x) = f x zero 
#+END_SRC

*** DONE Напишите, что делают эти расширения языка: ~TypeSynonyms, MultiParamTypeClasses, ViewPatterns, RecordsWildCards~
~TypeSynonyms~ - типы-синонимы в конструкторах?
~MultiParamTypeClasses~ - несколько типов в объявлении класса.
~ViewPatterns~ - дает паттерн матчинг с функциями.
~RecordWildcards~ - упрощает работу с record: дает забивать на поля в паттерн-матчинге и конструкторах.
*** DONE Реализуйте ~traverse~ через ~sequence~.
#+BEGIN_SRC haskell
traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
sequence :: Monad m => t (m a) -> m (t a)
traverse f = sequence . fmap f
#+END_SRC
*** DONE Реализуйте ~sequence~ через ~traverse~.
#+BEGIN_SRC haskell
sequence = traverse id -- так?
#+END_SRC
*** DONE Укажите *minimal complete definition* для type class'а ~Foldable~
    foldMap | foldr
*** DONE Укажите *minimal complete definition* для type class'а ~Traversable~
    traverse | sequenceA
** [5/5]Question 5: Functors
*** DONE Напишите законы *функтора*
#+BEGIN_SRC haskell
1. fmap id = id
2. fmap (f . g)   = (fmap f) . (fmap g)
   fmap (f . g) F = fmap f (fmap g F)
#+END_SRC
*** DONE Реализуйте функцию ~(<<$>>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)~ 
#+BEGIN_SRC haskell
(<<$>>) f w = (fmap $ fmap f) w
#+END_SRC
*** DONE Напишите класс типов ~Bifunctor~ и реализуйте его для пары
#+BEGIN_SRC haskell
class Bifunctor p where
    bimap  :: (a -> b) -> (c -> d) -> p a c -> p b d
instance Bifunctor (,) where
    bimap f g (a, b) = (f a, g b)
#+END_SRC
*** DONE Напишите класс типов ~Bifunctor~ и реализуйте его для ~Either~
#+BEGIN_SRC haskell
instance Bifunctor Either where
    bimap f _ (Left a)  = Left  (f a)
    bimap _ g (Right b) = Right (g b)
#+END_SRC
*** DONE Реализуйте ~fmap~ через ~bind~
#+BEGIN_SRC haskell
<$> :: Functor f => (a -> b) -> f a -> f b
>>= :: Monad m => m a -> (a -> m b) -> m b

f <$> a = a >>= (return . f)
#+END_SRC
** [9/10]Question 6: Applicatives
*** DONE Напишите законы *аппликатива*
#+BEGIN_SRC haskell
1. identity
   pure id <*> v = v
2. composition
   pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
3. homomorphism
   pure f <*> pure x = pure (f x)
4. interchange
   u <*> pure y = pure ($ y) <*> u
#+END_SRC
*** DONE Напишите type class ~Applicative~ и его реализацию для ~((->) r)~
#+BEGIN_SRC haskell
class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
    (*>) :: f a -> f b -> f b
    (<*) :: f a -> f b -> f a

instance Applicative ((->) r) where
    pure x = \_ -> x
    f <*> g = \x -> f x (g x)
#+END_SRC
*** DONE Напишите type class ~Applicative~ и его реализацию для ~Maybe~
#+BEGIN_SRC haskell
class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
    (*>) :: f a -> f b -> f b
    (<*) :: f a -> f b -> f a

instance Applicative Maybe where
    pure = Just
    Just f  <*> a = f <$> a
    Nothing <*> _ = Nothing
#+END_SRC
*** DONE Напишите type class ~Applicative~ и его реализацию для ~[]~
#+BEGIN_SRC haskell
class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
    (*>) :: f a -> f b -> f b
    (<*) :: f a -> f b -> f a

instance Applicative [] where
    pure x    = [x]
    fs <*> xs = [f x | x <- xs, f <- fs]
#+END_SRC
*** DONE Напишите type class ~Applicative~ и его реализацию для ~ZipList~
#+BEGIN_SRC haskell
class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
    (*>) :: f a -> f b -> f b
    (<*) :: f a -> f b -> f a

newtype ZipList a = zipList { getZipList :: [a] }
instance Applicative ZipList where
    pure x                        = ZipList (repeat x)
    (ZipList fs) <*> (ZipList xs) = ZipList (zipWith ($) fs gs)
#+END_SRC
*** DONE Реализуйте функцию ~liftA3~
#+BEGIN_SRC haskell
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
liftA3 f a b c = f <$> a <*> b <*> c
-- насколько я понимаю, так можно проворачивать с любым числом аргументов
#+END_SRC
*** DONE Реализуйте функцию ~liftAA2 :: (Applicative f, Applicative g) => (a -> b -> c) -> f (g a) -> f (g b) -> f (g c)~
#+BEGIN_SRC haskell
liftAA2 = liftA2 . liftA2
#+END_SRC
*** TODO Реализуйте функцию ~(<<*>>) :: (Applicative f, Applicative g) => f (g (a -> b)) -> f (g a) -> f (g b)~
#+BEGIN_SRC haskell
#+END_SRC
*** DONE Реализуйте функцию ~eitherA :: (Alternative f) => f a -> f b -> f (Either a b)~
#+BEGIN_SRC haskell
eitherA f1 f2 = fmap (Left) f1
#+END_SRC
*** DONE Есть функция ~g :: a -> b~ и объект ~x :: Applicative f => f a~. Напишите два разных способа получить объект ~y :: Applicative f => f b~ из ~x~ с использованием ~g~.
#+BEGIN_SRC haskell
getY :: (Applicative f) => (a -> b) -> f a -> f b
getY = fmap
getY = (<$>)
getY g x = pure g <*> x
#+END_SRC
** [19/19]Question 7: Monads
*** DONE Что такое монада?
Монады применяют функции, которые возвращают завернутые значения, к завернутому знаению.
#+BEGIN_SRC haskell
class Monad m where   -- m :: * -> *
    return :: a -> m a                  -- return
    (>>=)  :: m a -> (a -> m b) -> m b  -- bind
    (>>)   :: m a -> m b -> m b         -- then
    m >> k = m >>= \_ -> k
(=<<) :: Monad m => (a -> m b) -> m a -> m b
f =<< x = x >>= f
infixl 1  >>, >>=
infixr 1  =<<
#+END_SRC 
*** DONE Напишите не меньше пяти типов данных, являющихся монадой
1. []
2. Maybe
3. Either
4. IO
5. State
6. Identity
7. Writer
8. Reader
9. RWS
10. Cont
*** DONE Напишите не менее семи функций, полезных при работе с монадами
1. return
2. >>=
3. =<<
4. >>
5. liftM
6. liftM2
7. >=>
8. <=<
9. join
10. ifM
11. (||^)
*** DONE Напишите тип функции ~join~ и приведите несколько примеров использования
#+BEGIN_SRC haskell
join :: Monad m => m (m a) -> m a
ghci> join [[1,2], [3,4]]
[1,2,3,4]
ghci> join Just (Just 3)
Just 3
#+END_SRC
*** DONE Реализуйте ~join~ через ~bind~.
#+BEGIN_SRC haskell
join :: Monad m => m (m a) -> m a
(>>=) :: m a -> (a -> m b) -> m b

join x = x >>= id
#+END_SRC 
*** DONE Напишите реализацию ~Monad~ для списка
#+BEGIN_SRC haskell
data [a] = [] | a : [a]

instance Monad [] where
    return x = [x]
    xs >>= f = concat (map f xs)
#+END_SRC
*** DONE Напишите реализацию ~Monad~ для ~Maybe~
#+BEGIN_SRC haskell
data Maybe a = Nothing | Just a

instance Monad Maybe where
    return = Just
    Nothing >>= _ = Nothing
    Just a  >>= f = f a
#+END_SRC 
*** DONE Напишите реализацию ~Monad~ для ~Either~
#+BEGIN_SRC haskell
data Either a b = Left a | Right b

instance Monad (Either a) where
    return  = Right
    Right r >>= f = f r
    Left l  >>= _ = Left l
#+END_SRC
*** DONE Напишите реализацию ~Monoid~ для ~Maybe~ 
#+BEGIN_SRC haskell
instance Monoid a => Monoid (Maybe a) where
    mempty = Nothing
    Nothing `mappend` m = m
    m `mappend` Nothing = m
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
#+END_SRC
*** DONE Напишите реализацию ~Monoid~ для ~(->)~
#+BEGIN_SRC haskell
instance Monoid b => Monoid (a -> b) where
    mempty _ = mempty
    mappend f g x = f x `mappend` g x
#+END_SRC
*** DONE Напишите определение типа данных ~Writer~ и его ~instance Monad~
#+BEGIN_SRC haskell
newtype Writer w a = Writer { runWriter :: (a, w) } -- a is value, w is log
-- Writer w a type is just a newtype wrapper for a tuple (a, w); just a reminder of what newtype is

instance Monoid w => Monad (Writer w) where
    return a            = Writer (a, mempty)
    Writer (x, v) >>= f = let Writer (y, v') = f x
                          in Writer (y, v `mappend` v')

#+END_SRC
*** DONE Напишите определение типа данных ~Reader~ и его ~instance Monad~
#+BEGIN_SRC haskell
newtype Reader e a = Reader { runReader :: e -> a }

instance Monad (Reader e) where
    return a = Reader $ \_ -> a
    m >>= f  = Reader $ \r -> runReader (f $ runReader m r) r
#+END_SRC
*** DONE Напишите определение типа данных ~State~ и его ~instance Monad~
#+BEGIN_SRC haskell
newtype State s a = State { runState :: s -> (a, s) }
instance Monad (State s) where
    return a       = State $ \s -> (a, s)
    oldState >>= f = State $ \s -> let (a, newState) = runState oldState s
                                   in runState (f a) newState
#+END_SRC
*** DONE Напишите определение типа данных ~Cont~ и его ~instance Monad~
#+BEGIN_SRC haskell
newtype Cont r a = Cont { runCont :: (a -> r) -> r }

instance Monad (Cont r) where
    return a = Cont ($ a)
    Cont arr >>= f = Cont $ \br -> arr $ \a -> runCont (f a) br
#+END_SRC
*** DONE Напишите тип ~(>=>)~ и смысл этого оператора.
#+BEGIN_SRC haskell
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
#+END_SRC
Композиция функций, возвращающих завернутое значение. =
*** DONE Покажите, синтаксическим сахаром для чего является ~do~-нотация (включая ~let~).
#+BEGIN_SRC haskell
-- two-line do notation
do x <- m
   e
-- desugars to:
m >>= (\x -> e)

-- one-line do notation
main = do putStrLn "hello, world"
-- you can just remove do
main = putStrLn "hello, world"

-- multi-line do notation
do x <- mx
   y <- my
   z
-- is equivalent to:
do x <- mx
   do y <- my
      z
-- desugars to:
mx >>= (\x ->
my >>= (\y ->
z ))

-- non-recursive let in a do block desugars to a lambda:
do let x = y
   z
-- desugars to
(\x -> z) y
#+END_SRC
*** DONE Напишите тип ~(>=>)~ и смысл этого оператора.
#+BEGIN_SRC haskell
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
#+END_SRC
композиция монад?
Композиция функций, возвращающих завернутое значение. 
*** DONE Что такое ~IO~? Как теоретически это реализовано? 
#+BEGIN_SRC haskell
data IO a :: * -> *
instance Monad IO where
    (>>=) = bindIO
#+end_src
*** DONE Отличие ~unsafePerformIO~ от ~unsafeInterleaveIO~?
unsafeInterleaveIO дает дополнительные гарантии на порядок операций, идейно так реализовано:
#+BEGIN_SRC haskell
do
    before
    unsafeInterleaveIO side
    after
#+end_src
Гарантируется, что то, что в side всегда выполнится после before. unsafePerformIO таких гарантий не дает.

** [7/7]Question 8: Trans
*** DONE Напишите класс типов ~MonadTrans~ и реализуйте его для ~StateT~
#+BEGIN_SRC haskell
  class MonadTrans t where    -- t :: (* -> *) -> * -> *
      lift :: Monad m => m a -> t m a
  instance MonadTrans (StateT s) where
      lift m = StateT $ \s -> do
          a <- m
          return (a, s)
#+END_SRC
*** DONE Напишите класс типов ~MonadTrans~ и реализуйте его для ~WriterT~
#+BEGIN_SRC haskell
  instance (Monoid w) => MonadTrans (WriterT w) where
      lift m = WriterT $ do
          a <- m
          return (a, mempty)
#+END_SRC
*** DONE Напишите класс типов ~MonadTrans~ и реализуйте его для ~MaybeT~
#+BEGIN_SRC haskell
  instance MonadTrans MaybeT where
      lift = MaybeT . liftM Just
#+END_SRC
*** DONE Напишите класс типов ~MonadTrans~ и реализуйте его для ~ReaderT~
#+BEGIN_SRC haskell
  instance MonadTrans ReaderT where
     lift m = ReaderT (const m)
#+END_SRC
*** DONE Напишите тип ~StateT~ и то, как определен ~State~ через ~StateT~
#+BEGIN_SRC haskell
  newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
  type State s = StateT s Identity
#+END_SRC
*** DONE Напишите тип ~MaybeT~ и реализуйте его инстанс ~Monad~
#+BEGIN_SRC haskell
  newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
  instance (Monad m) => Monad (MaybeT m) where
      fail _ = MaybeT (return Nothing)
      return = lift . return
      x >>= f = MaybeT $ do
          v <- runMaybeT x
          case v of
              Nothing -> return Nothing
              Just y  -> runMaybeT (f y)
#+END_SRC
*** DONE Нарисуйте табличку отличий обычных типов и их трансформеров для известных вам трансформеров
| Base monad | Transformer | Original type | Combined type     |
| Maybe      | MaybeT      | Maybe a       | m (Maybe a)       |
| Either     | EitherT     | Either a b    | m (Either a b)    |
| Writer     | WriterT     | (a, w)        | m (a, w)          |
| Reader     | ReaderT     | r -> a        | r -> m a          |
| State      | StateT      | s -> (a,s)    | s -> m (a, s)     |
| Cont       | ContT       | (a -> r) -> r | (a -> m r) -> m r |
** [10/10]Question 9: Strict Lazy
*** DONE Что такое *irrefutable patterns* и зачем они нужны?
Ленивые паттерны. Матчинг значения v на паттерн ~pat всегда успешный, независимо от pat. Может понадобиться, если у нас есть бесконечная структура, определенная рекурсивно.
*** DONE Что такое *Stream Fusion* и зачем он нужен?
Пишем что-нибудь вроде функций с бесконечными списками, аллоцируем слишком много памяти. Stream fusion превращает нашу функцию во что-то, что использует рекурсивную функцию, которая аллоцирует себе столько памяти, сколько нужно для *результата*. Вместо явной рекурсии можем использовать нерекурсивные функции над списком, которые используют допустимые функции ~map~, ~foldr~ и так далее. Тут стало слишком много Inception.
*** DONE Напишите, что значит тип ~ST~ и напишите основные функции по работе с ним
Монада, в которой есть мутабельные переменные и массивы, но при этом она referentially transparent. Strict state-transformer monad.
~new/read/write/modifySTRef~, ~runST~.
*** DONE Что такое ~BangPatterns~? Когда их нужно использовать? 
Используем ! и убиваем ленивость. Делаем это, когда долго работаем и ломаемся по памяти; при арифметических операциях, рекурсии и подозрениях на утечки памяти.
*** DONE Укажите, что делает ~deepseq~ и как.
~deepseq~ полностью вычисляет структуру (до нормальной формы). Обходит структуру "глубоко", например, ~seq~ вычислит до первого конструктора в списке, а ~deepseq~ зафорсит вычисление всех элементов списка.
*** DONE В чем разница между ~seq~ и ~deepseq~?
Первый вычисляет до WHNF, второй - до нормальной формы. Работает так: если вычислился результат ~seq~, то и аргумент тоже вычислен.
*** DONE В чем разница между ~seq~ и ~BangPatterns~?
~BangPatterns~ удобнее пишется, особенно в больших количествах, а так это вроде синтаксический сахар для ~seq~.
*** DONE Что такое ~STRef~ и в чем отличие от ~IORef~?
~STRef~ - укзатель на мутабельный контейнер в монаде ~ST~, а ~IORef~, соответственно, в ~IO~. А по сути это вроде одно и то же.
*** DONE Что такое *Deforestation*?
Избавляемся от аллокации промежуточных списков. По сути сливаем одинаковые вызовы функций в один.
#+BEGIN_SRC haskell
  map f . map g = map (f . g)
#+END_SRC
*** DONE Чем плохо использовать ~IORef~ и ~IOArray~? Зачем нужны ~STRef~ и ~STArray~?
~IOArray~ не очень мутабельный, IO-монада дает больше возможностей, но они не всегда нужны. А еще ST-операции можно делать в чистых функциях. Вообще ~STRef~ используем, когда мутабельность нам не снаружи дают, а она является деталью имплементации, и снаружи наша деятельность кажется вполне себе чистой.
** [4/4]Question 10: TemplateHaskell
*** DONE Как можно посмотреть *AST-дерево* для выражения в Haskell?
#+BEGIN_SRC haskell
  report :: Bool -> String -> Q ()
#+END_SRC
Но вообще цитирующими скобками же, наверное.
*** DONE Напишите не меньше трех применений *TemplateHaskell*
- Писать функции n аргументов
- Генерировать автоматом инстансы
- Что-то высчитывать во время компиляции, тип один раз и навсегда.
- Парсить всякие структуры типа json
- Генерировать автоматом линзы
*** DONE Что такое ~Q~ в типах функций Template Haskell?
~Q~ - монада цитирования, которая позволяет автоматически генерировать уникальные имена для переменных с помощью монадической функции ~newName :: String -> Q Name~.
*** DONE В чем разница между ~[| |]~ и ~$()~?
~[| |]~ - quasi quotes, ~$()~ - вклейка (splice). Цитирующие скобки преобразуют конкретный хаскель-код в структуру ~Exp~ (получают AST), а вклейка - подставляет AST на место шаблона, поэтому это взаимно обратные операции.
** [6/10]Question 11: Lenses
*** DONE Что такое изоморфизм (~Iso~)?
Изоморфизм - связь между эквивалентными типами. ~Iso~ - пара маппингов из первого типа во второй и из второго с первый, таких, что:
#+BEGIN_SRC haskell
  fw . bw = id
  bw . fw = id
#+END_SRC
*** DONE Чем линзы отличаются от призм?
Призмы - это как линзы, но линзы смотрят на часть типа-произведения, а призмы спускаются на уровень ниже в типе-сумме вроде ~Either~ или падают.
*** DONE Напишите тип ~Iso~
#+BEGIN_SRC haskell
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
#+END_SRC 
*** DONE Напишите тип функции ~from~ для ~Iso~
#+BEGIN_SRC haskell
from :: AnIso s t a b -> Iso b a t s
#+END_SRC
*** DONE Напишите тип функции ~iso~
#+BEGIN_SRC haskell
iso :: (s -> a) -> (b -> t) -> Iso s t a b
#+END_SRC
*** TODO Напишите реализацию ~over~
*** TODO Реализуйте ~set~ через ~over~
*** TODO Реализуйте ~over~ через ~view~ и ~set~. 
*** TODO Напишите функцию ~lens~, которая принимает геттер и сеттер и возвращает линзу
*** DONE Укажите операторные обозначений функций ~view~, ~set~, ~over~. Есть ли отличие в типах функций и их операторных выражений?
view == (^.), set == (.~), over == (%~). Отличий не знаю.
** [8/8]Question 12: Threads
*** DONE Что такое ~STM~ (коротко), что позволяет делать и какие есть функции по работе с ним?
Software Transactional Memory - абстракция для concurrent communication, хороша тем, что две concurrent абстракции можно легко слепить в одну и не придется светить деталями реализации; позволяет выполнить транзакцию (либо все операции успешно, либо откат). Функции ~newTVar/readTVar/writeTVar, atomically, retry, orElse~.
*** DONE В чем отличие Haskell потоков от, например, потоков в Java?
Много хаскель-тредов могут быть замаплены на один ОС-тред, потому что в действительности этот ОС-тред всего лишь гоняет хаскель-рантайм. А рантайм сам разбирается со своим внутренним шедулингом, yield'ами и прочим. Это, кстати, уменьшает оверхед, который ось обычно тратит на context switching.
*** DONE Что такое ~Strategy~? Перечислите несколько стратегий и реализуйте некоторые. Зачем они нужны?
Стратегии позволяют выразить паралельные вычисления, то есть:
- поддерживают deterministic parallelism: результат программы не зависит от параллельных вычислений. Никаких сайд-эффектов.
- отделяют описание параллелизма от логики самой программы (модульность - здорово!). Делаем ленивую структуру, которая представляет собой наши вычисления, а потом пишем под нее стратегию, которая описывает, как обходить эту структуру и делать вычисления последовательно или параллельно.
- композиция! Берем маленькие стратегии, из них делаем большую.
- есть инстансы ~Monad~ и ~Applicative~ для удобства тривиальных случаев
Примеры:
- ~r0~: ничего не делай.
- ~rseq~: вычислить до WHNF.
- ~rdeepseq~: вычисли меня полностью. ~%op = evalSeq Control.Seq.%op~.
- ~rpar~: сделаем спарк для параллельного вычисления.
- ~rparWith~: композиция. Не покидает монаду ~Eval~, не имеет встроенного ~rseq~. 
*** DONE Как в Haskell обстоят дела с *DeadLock*'ами?
Когда рантайм GHC находит группу тредов, которые все заблочены на блокирующих мутабельных переменных (~MVar~ или переменные ~STM~), и видит, что другие треды на них не ссылаются, он решает, что все треды в дедлоке и отсылает им асинхронные исключения ~BlockedIndefinitelyOnMVar/STM~. Кстати, ловить асинхронные исключения моветон.
*** DONE Что такое *RTS*?
RunTime System. 50k строк сишного кода, хайлайты:
- содержит всякий вспомогательный код, который позволяет бросить эксепшн после ~error~, аллоцировать ~Array#~, организовать работу с ~MVar~.
- включает в себя менеджер памяти плюс сборщик мусора.
- содержит userspace-шедулер для хаскель-тредов, с поддержкой шедулинга их на несколько процессоров, и позволяет хаскель-тредам вызывать внешние функции в разных тредах ОС.
- содержит интерпретатор байткода для GHCi и динамический линковщик туда же.
- может в разный профайлинг и покрытие кода.
- поддержка STM.
*** DONE Укажите несколько полезных опций *RTS*
-Asize/-Hsize/-Msize, -threaded, -Nn, -prof
*** DONE Опишите, что такое ~MVar~, зачем он может быть нужен и несколько функций по работе с этим объектом.
~MVar T~ - Мутабельная переменная, которая либо пуста, либо содержит значение типа t. Можно использовать как синхронизированную мутабельную переменную, как канал или как семафор. Функции: ~takeMVar~, ~putMVar~, read/swap/with/modifyMVar
*** DONE Что делает ~forkIO~? Чем он отличается от ~forkFinally~?
~forkIO~ создает новый легковесный тред, где запустится IO, переданное в качестве аргумента, и возвращает его айдишник. Почему-то игнорирует исключения про дедлоки и убийство треда и пробрасывает остальные исключения как обычно.
~forkFinally~ форкает тред и, когда тот должен умереть, вызывает функцию, переданную аргументом, на эксепшне или возвращаемом значении. Своего рода хэндлер чего-то.
** [5/5]Question 13: forall
*** DONE Напишите, как иметь список объектов разных функторов, внутри каждого из которых значения одинакового типа, чтобы иметь возможность применить функции из этого значения в другое?
#+BEGIN_SRC haskell
data FunctorBox a = forall f . Functor f => FB (f a)
FB :: forall {a} {f :: * -> *} . Functor f => f a -> FunctorBox a -- as ghci sees it

fmapFB :: forall t a . (t -> a) -> FunctorBox t -> FunctorBox a
fmapFB f = \(FB a) -> FB (f <$> a)
#+END_SRC
*** DONE Зачем нужно расширение ~ExistentialQuantification~?
Для того, чтобы работать со значениями разных типов, но обладающими каким-то свойством (например, они одного класса), одинаково. Например, чтобы иметь возможность складывать такие значения в лист, получая тем самым гетерогенный лист, спрятав значения в некоторую "коробку" (/type hider/)
*** DONE Зачем нужно расширение языка ~-XExplicitForall~?
Чтобы явно аннотировать типы с использованием ~forall~
*** DONE В чем разница между ~-XRank2Types~ и ~-XRankNTypes~? Зачем нужны оба?
~-XRank2Types~ разрешает полиморфные типы ранга 2, ~-XRankNTypes~ разрешает полиморфные типы любого ранга. 
В системах с полиморфными типами ранга 2 задача вывода типов разрешима, если же ранг > 2, то задача становится неразрешимо и возникает необходимость явной аннотации типов. С этим и связана необходимость разделения этих расширений языка.
*** DONE Зачем нужно расширение языка ~-XScopedTypeVariables~ и как оно взаимодействует с ~forall~?
Позволяет указывать, что переменные типа из сигнатуры распространяются на тело функции. Чтобы это работало, надо использовать ~forall~ в сигнатуре:
#+BEGIN_SRC haskell
  {-# LANGUAGE ScopedTypeVariables #-}
  import Data.List

  main = putStrLn "No errors."

  -- show
  myFunction :: forall a. Ord a => [a] -> [(a, a)]
  myFunction inputList = zip sortedList nubbedList
      where sortedList :: [a]
            sortedList = sort inputList
            nubbedList :: [a]
            nubbedList = nub inputList
  -- /show
#+END_SRC
** [4/5]Question 14: Advanced types
*** DONE Что такое *typed holes* и зачем они нужны?
С их помощью можно спросить у компилятора, какого типа должно быть твое что-то.
#+BEGIN_SRC haskell
  mfold :: [Maybe a] -> [Either a b]
  mfold = foldr _f _z

  > Found hole ‘_f’ with type: Maybe a -> [Either a b] -> [Either a b]
  > Found hole ‘_z’ with type: [Either a b]
#+END_SRC
*** DONE Зачем нужно расширение языка ~-XTypeApplications~?
Позволяет задавать явные аргументы типов полиморфной функции, например ~map @Int @Bool isEven xs~. Решает проблему show/read, потому что мы явно задаем типы и все тайпчекается.
#+BEGIN_SRC haskell
  answer_read = show (read @Int "3") -- "3" :: String
  answer_show = show @Integer (read "5") -- "5" :: String
  answer_showread = show @Int (read @Int "7") -- "7" :: String
#+END_SRC
*** DONE Зачем нужно расширение языка ~-XPartialSignatures~?
Аналог typed holes для сигнатур функций:
#+BEGIN_SRC haskell
  arbitCs :: _ => a -> String
  arbitCs x = show (succ x) ++ show (x == x)
  Main.hs:6:12: warning: [-Wpartial-type-signatures]
      Found constraint wildcard ‘_’ standing for ‘(Show a, Eq a, Enum a)’
      In the type signature:
        arbitCs :: _ => a -> String
#+END_SRC
*** TODO Можно ли создать следующий тип данных в Haskell: ~data a : > b = (a -> b) : > (b -> a)~?
*** DONE Что такое *Functional Dependencies*? Назовите какой-нибудь известный вам type class, в котором присутствуют функциональные зависимости.
Функциональные зависимости используются для ограничения параметров тайпклассов. Они позволяют объявить, что в тайпклассе с несколькими параметрами один из параметров можно *однозначно!* определить по другим.
#+BEGIN_SRC haskell
class Mult a b c | a b -> c where
  (*) :: a -> b -> c
#+END_SRC
Классический (и единственный) пример использования - перемножение матриц/векторов/скаляров, тайпкласс указан выше.
** [0/11]Question 15: Comonads
*** TODO Напишите пример использования *комонад* 
*** TODO Напишите, какие комонады двойственны монадам ~Reader, Writer, State~
*** TODO Напишите, какие комонады двойственны монадам ~Traced, Store, Env~
*** TODO Напишите комонаду ~Stream~ и инстанс ~Comonad~ для нее.
*** TODO Напишите комонаду ~Env~ и инстанс ~Comonad~ для нее.
*** TODO Напишите комонаду ~Store~ и инстанс ~Comonad~ для нее.
*** TODO Напишите комонаду ~Traced~ и инстанс ~Comonad~ для нее.
*** TODO Реализуйте ~instance Comonad~ для обычного ~Zipper~
*** TODO ~IO~ использует абстракцию монад, какой аналог есть в мире комонад?
*** TODO Напишите класс ~ComonadTrans~
*** TODO Как можно было бы сделать ~codo~ нотацию для комонад? И что бы происходило в этом синтаксическом сахаре?
** [0/8]Question 16: Idris
*** TODO Реализуйте функцию ~take~ для вектора на Idris
*** TODO Реализуйте функцию ~filter~ для вектора на Idris
*** TODO Реализуйте функцию ~head~ для списка на Idris, которая компилируется только с гарантированно непустыми списками.
*** TODO Напишите тип "*зависимая пара*" на Idris
*** TODO Что такое ~[| |]~-идиома в Idris?
*** TODO Что такое ~!~-идиома в Idris?
*** TODO Что такое ~_|_-eliminator~? Зачем это надо?
*** TODO Что такое "*тотальность*" и какие преимущества она дает? 
